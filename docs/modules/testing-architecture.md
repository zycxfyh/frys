# frys æµ‹è¯•æ¶æ„

## ğŸ“– æ¦‚è¿°

frys æä¾›äº†ä¸€å¥—å®Œæ•´çš„æµ‹è¯•ä½“ç³»ï¼Œç¡®ä¿ä»£ç è´¨é‡å’Œç³»ç»Ÿç¨³å®šæ€§ã€‚æµ‹è¯•æ¶æ„é‡‡ç”¨åˆ†å±‚è®¾è®¡ï¼Œè¦†ç›–ä»å•å…ƒæµ‹è¯•åˆ°ç«¯åˆ°ç«¯æµ‹è¯•çš„å®Œæ•´æµ‹è¯•é‡‘å­—å¡”ã€‚

### ğŸ¯ æµ‹è¯•ç­–ç•¥

- **è´¨é‡ä¼˜å…ˆ**: æµ‹è¯•é©±åŠ¨å¼€å‘ï¼Œç¡®ä¿ä»£ç è´¨é‡
- **è‡ªåŠ¨åŒ–ä¸ºä¸»**: æœ€å¤§åŒ–è‡ªåŠ¨åŒ–æµ‹è¯•è¦†ç›–ç‡
- **åˆ†å±‚æµ‹è¯•**: éµå¾ªæµ‹è¯•é‡‘å­—å¡”æ¨¡å‹
- **æŒç»­é›†æˆ**: æµ‹è¯•é›†æˆåˆ°CI/CDæµç¨‹
- **ç›‘æ§åé¦ˆ**: å®æ—¶ç›‘æ§æµ‹è¯•ç»“æœå’Œè´¨é‡æŒ‡æ ‡

### ğŸ§ª æµ‹è¯•å±‚æ¬¡

```
æµ‹è¯•é‡‘å­—å¡”
    â–²
    â”‚     ç«¯åˆ°ç«¯æµ‹è¯• (10%)
    â”‚     å°‘é‡ã€å…³é”®ç”¨æˆ·æµç¨‹
    â”‚
    â”‚     é›†æˆæµ‹è¯• (20%)
    â”‚     æ¨¡å—é—´åä½œã€æœåŠ¡é›†æˆ
    â”‚
    â”‚     å•å…ƒæµ‹è¯• (70%)
    â”‚     æ ¸å¿ƒåŠŸèƒ½ã€ä¸šåŠ¡é€»è¾‘
    â–¼
```

### ğŸ“Š æµ‹è¯•è¦†ç›–ç›®æ ‡

| æµ‹è¯•ç±»å‹ | è¦†ç›–ç‡ç›®æ ‡ | æ‰§è¡Œé¢‘ç‡ | ä¸»è¦èŒè´£ |
|----------|------------|----------|----------|
| å•å…ƒæµ‹è¯• | 80%+ | æ¯æ¬¡æäº¤ | æ ¸å¿ƒé€»è¾‘æ­£ç¡®æ€§ |
| é›†æˆæµ‹è¯• | 60%+ | æ¯æ—¥æ„å»º | æ¨¡å—é—´åä½œ |
| ç«¯åˆ°ç«¯æµ‹è¯• | 30%+ | å‘å¸ƒå‰ | ç”¨æˆ·æµç¨‹å®Œæ•´æ€§ |
| æ€§èƒ½æµ‹è¯• | å…³é”®è·¯å¾„ | å®šæœŸæ‰§è¡Œ | ç³»ç»Ÿæ€§èƒ½è¡¨ç° |
| å®‰å…¨æµ‹è¯• | 100% | å®šæœŸæ‰§è¡Œ | å®‰å…¨æ¼æ´æ£€æŸ¥ |

## ğŸ§ª å•å…ƒæµ‹è¯•

### åŠŸèƒ½ç‰¹æ€§

- **å¿«é€Ÿæ‰§è¡Œ**: æ¯«ç§’çº§å“åº”æ—¶é—´
- **ç‹¬ç«‹è¿è¡Œ**: æ— å¤–éƒ¨ä¾èµ–ï¼Œçº¯é€»è¾‘æµ‹è¯•
- **å…¨é¢è¦†ç›–**: è¯­å¥ã€åˆ†æ”¯ã€æ¡ä»¶è¦†ç›–
- **æŒç»­åé¦ˆ**: å¼€å‘æ—¶å®æ—¶è¿è¡Œ
- **è°ƒè¯•å‹å¥½**: è¯¦ç»†çš„é”™è¯¯ä¿¡æ¯å’Œå †æ ˆè·Ÿè¸ª

### æµ‹è¯•æ¡†æ¶

frys ä½¿ç”¨ Vitest ä½œä¸ºå•å…ƒæµ‹è¯•æ¡†æ¶ï¼Œæä¾›ä»¥ä¸‹ç‰¹æ€§ï¼š

- **ESMåŸç”Ÿæ”¯æŒ**: å®Œæ•´çš„ESæ¨¡å—æ”¯æŒ
- **TypeScriptå‹å¥½**: å†…ç½®TypeScriptæ”¯æŒ
- **Jestå…¼å®¹**: ç†Ÿæ‚‰çš„APIå’Œæ–­è¨€
- **å¹¶è¡Œæ‰§è¡Œ**: å¤šæ ¸CPUå……åˆ†åˆ©ç”¨
- **æ™ºèƒ½é‡è¯•**: å¤±è´¥æµ‹è¯•è‡ªåŠ¨é‡è¯•

### å¿«é€Ÿå¼€å§‹

```javascript
import { describe, it, expect, vi } from 'vitest';
import { UserService } from '../src/services/UserService.js';

describe('UserService', () => {
  let userService;
  let mockRepository;

  beforeEach(() => {
    // è®¾ç½®æµ‹è¯•ä¾èµ–
    mockRepository = {
      create: vi.fn(),
      findById: vi.fn(),
      update: vi.fn(),
      delete: vi.fn()
    };

    userService = new UserService({
      userRepository: mockRepository,
      auth: mockAuth,
      logger: mockLogger
    });
  });

  describe('createUser', () => {
    it('should create user successfully', async () => {
      // å‡†å¤‡æµ‹è¯•æ•°æ®
      const userData = {
        username: 'john_doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const expectedUser = {
        id: 'user_123',
        ...userData,
        createdAt: new Date(),
        status: 'active'
      };

      // è®¾ç½®æ¨¡æ‹Ÿè¡Œä¸º
      mockRepository.create.mockResolvedValue(expectedUser);

      // æ‰§è¡Œæµ‹è¯•
      const result = await userService.createUser(userData);

      // éªŒè¯ç»“æœ
      expect(result).toEqual(expectedUser);
      expect(mockRepository.create).toHaveBeenCalledWith(userData);
    });

    it('should throw error for duplicate email', async () => {
      const userData = {
        username: 'jane_doe',
        email: 'john@example.com', // é‡å¤é‚®ç®±
        password: 'password123'
      };

      // æ¨¡æ‹Ÿé‚®ç®±å·²å­˜åœ¨
      mockRepository.create.mockRejectedValue(
        new Error('Email already exists')
      );

      // éªŒè¯æŠ›å‡ºé”™è¯¯
      await expect(userService.createUser(userData))
        .rejects.toThrow('Email already exists');
    });

    it('should validate required fields', async () => {
      const invalidData = {
        username: '', // ç©ºç”¨æˆ·å
        email: 'invalid-email', // æ— æ•ˆé‚®ç®±
        password: '123' // å¯†ç å¤ªçŸ­
      };

      await expect(userService.createUser(invalidData))
        .rejects.toThrow('Validation failed');
    });
  });

  describe('getUserById', () => {
    it('should return user when found', async () => {
      const userId = 'user_123';
      const expectedUser = {
        id: userId,
        username: 'john_doe',
        email: 'john@example.com'
      };

      mockRepository.findById.mockResolvedValue(expectedUser);

      const result = await userService.getUserById(userId);

      expect(result).toEqual(expectedUser);
      expect(mockRepository.findById).toHaveBeenCalledWith(userId);
    });

    it('should return null when user not found', async () => {
      const userId = 'nonexistent';

      mockRepository.findById.mockResolvedValue(null);

      const result = await userService.getUserById(userId);

      expect(result).toBeNull();
    });
  });
});
```

### Mock å’Œ Stub

```javascript
// ä½¿ç”¨ Vitest çš„å†…ç½® Mock
import { vi } from 'vitest';

// Mock æ•´ä¸ªæ¨¡å—
vi.mock('../src/utils/email.js', () => ({
  sendWelcomeEmail: vi.fn().mockResolvedValue(true)
}));

// Mock éƒ¨åˆ†æ–¹æ³•
const mockHttpClient = {
  get: vi.fn(),
  post: vi.fn(),
  put: vi.fn(),
  delete: vi.fn()
};

// Mock è¿”å›å€¼
mockHttpClient.get.mockResolvedValue({
  data: { id: 1, name: 'John' },
  status: 200
});

// Mock å¼‚å¸¸
mockHttpClient.post.mockRejectedValue(
  new Error('Network error')
);

// éªŒè¯è°ƒç”¨
expect(mockHttpClient.get).toHaveBeenCalledWith('/api/users/1');
expect(mockHttpClient.get).toHaveBeenCalledTimes(1);
```

### æµ‹è¯•è¦†ç›–ç‡

```javascript
// vitest.config.js
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        'test/',
        'docs/',
        '**/*.config.js'
      ],
      thresholds: {
        global: {
          statements: 80,
          branches: 75,
          functions: 85,
          lines: 80
        }
      }
    }
  }
});
```

## ğŸ”— é›†æˆæµ‹è¯•

### åŠŸèƒ½ç‰¹æ€§

- **æ¨¡å—åä½œ**: æµ‹è¯•æ¨¡å—é—´çš„äº¤äº’
- **å¤–éƒ¨ä¾èµ–**: æ•°æ®åº“ã€ç¼“å­˜ã€æ¶ˆæ¯é˜Ÿåˆ—
- **APIæ¥å£**: RESTful API å’Œ GraphQL
- **å¼‚æ­¥å¤„ç†**: é˜Ÿåˆ—ä»»åŠ¡å’Œåå°ä½œä¸š
- **å®¹å™¨åŒ–**: ä½¿ç”¨ Testcontainers æä¾›éš”ç¦»ç¯å¢ƒ

### æµ‹è¯•ç¯å¢ƒ

#### Testcontainers é…ç½®

```javascript
import { PostgreSqlContainer, RedisContainer } from '@testcontainers/postgresql';
import { RedisContainer as Redis } from '@testcontainers/redis';

describe('User Integration Tests', () => {
  let postgresContainer;
  let redisContainer;
  let database;
  let cache;

  beforeAll(async () => {
    // å¯åŠ¨ PostgreSQL å®¹å™¨
    postgresContainer = await new PostgreSqlContainer()
      .withDatabase('testdb')
      .withUsername('testuser')
      .withPassword('testpass')
      .start();

    // å¯åŠ¨ Redis å®¹å™¨
    redisContainer = await new RedisContainer()
      .withPassword('testpass')
      .start();

    // è¿æ¥æ•°æ®åº“
    database = createDatabaseConnection({
      host: postgresContainer.getHost(),
      port: postgresContainer.getPort(),
      database: postgresContainer.getDatabase(),
      username: postgresContainer.getUsername(),
      password: postgresContainer.getPassword()
    });

    // è¿æ¥ç¼“å­˜
    cache = createRedisConnection({
      host: redisContainer.getHost(),
      port: redisContainer.getPort(),
      password: redisContainer.getPassword()
    });

    // åˆå§‹åŒ–æµ‹è¯•æ•°æ®
    await setupTestData(database);
  }, 60000); // 60ç§’è¶…æ—¶

  afterAll(async () => {
    // æ¸…ç†èµ„æº
    await database.close();
    await cache.disconnect();
    await postgresContainer.stop();
    await redisContainer.stop();
  });
});
```

### API é›†æˆæµ‹è¯•

```javascript
import request from 'supertest';
import { createApp } from '../src/app.js';

describe('User API Integration', () => {
  let app;
  let server;
  let testDatabase;

  beforeAll(async () => {
    // åˆ›å»ºæµ‹è¯•åº”ç”¨
    app = createApp({
      database: testDatabase,
      cache: testCache,
      queue: testQueue
    });

    // å¯åŠ¨æœåŠ¡å™¨
    server = app.listen(0); // éšæœºç«¯å£
  });

  afterAll(async () => {
    await server.close();
    await testDatabase.cleanup();
  });

  describe('POST /api/users', () => {
    it('should create user successfully', async () => {
      const userData = {
        username: 'john_doe',
        email: 'john@example.com',
        password: 'password123'
      };

      const response = await request(app)
        .post('/api/users')
        .send(userData)
        .expect(201);

      expect(response.body).toHaveProperty('id');
      expect(response.body.username).toBe(userData.username);
      expect(response.body.email).toBe(userData.email);
      expect(response.body).not.toHaveProperty('password'); // å¯†ç ä¸åº”è¿”å›
    });

    it('should validate input data', async () => {
      const invalidData = {
        username: '',
        email: 'invalid-email',
        password: '123'
      };

      const response = await request(app)
        .post('/api/users')
        .send(invalidData)
        .expect(400);

      expect(response.body).toHaveProperty('errors');
      expect(response.body.errors).toContain('Username is required');
      expect(response.body.errors).toContain('Invalid email format');
      expect(response.body.errors).toContain('Password too short');
    });

    it('should handle duplicate email', async () => {
      // å…ˆåˆ›å»ºç”¨æˆ·
      await request(app)
        .post('/api/users')
        .send({
          username: 'user1',
          email: 'duplicate@example.com',
          password: 'password123'
        })
        .expect(201);

      // å°è¯•åˆ›å»ºé‡å¤é‚®ç®±ç”¨æˆ·
      const response = await request(app)
        .post('/api/users')
        .send({
          username: 'user2',
          email: 'duplicate@example.com',
          password: 'password123'
        })
        .expect(409);

      expect(response.body.message).toContain('Email already exists');
    });
  });

  describe('GET /api/users/:id', () => {
    let createdUser;

    beforeEach(async () => {
      // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
      const response = await request(app)
        .post('/api/users')
        .send({
          username: 'testuser',
          email: 'test@example.com',
          password: 'password123'
        });

      createdUser = response.body;
    });

    it('should return user by id', async () => {
      const response = await request(app)
        .get(`/api/users/${createdUser.id}`)
        .expect(200);

      expect(response.body.id).toBe(createdUser.id);
      expect(response.body.username).toBe(createdUser.username);
    });

    it('should return 404 for non-existent user', async () => {
      const response = await request(app)
        .get('/api/users/nonexistent-id')
        .expect(404);

      expect(response.body.message).toBe('User not found');
    });
  });

  describe('PUT /api/users/:id', () => {
    it('should update user successfully', async () => {
      // å…ˆåˆ›å»ºç”¨æˆ·
      const createResponse = await request(app)
        .post('/api/users')
        .send({
          username: 'updateuser',
          email: 'update@example.com',
          password: 'password123'
        });

      const userId = createResponse.body.id;
      const updateData = {
        fullName: 'Updated Name',
        phone: '+1234567890'
      };

      // æ›´æ–°ç”¨æˆ·
      const updateResponse = await request(app)
        .put(`/api/users/${userId}`)
        .send(updateData)
        .expect(200);

      expect(updateResponse.body.fullName).toBe(updateData.fullName);
      expect(updateResponse.body.phone).toBe(updateData.phone);
    });
  });

  describe('DELETE /api/users/:id', () => {
    it('should delete user successfully', async () => {
      // å…ˆåˆ›å»ºç”¨æˆ·
      const createResponse = await request(app)
        .post('/api/users')
        .send({
          username: 'deleteuser',
          email: 'delete@example.com',
          password: 'password123'
        });

      const userId = createResponse.body.id;

      // åˆ é™¤ç”¨æˆ·
      await request(app)
        .delete(`/api/users/${userId}`)
        .expect(204);

      // éªŒè¯ç”¨æˆ·å·²è¢«åˆ é™¤
      await request(app)
        .get(`/api/users/${userId}`)
        .expect(404);
    });
  });
});
```

### æ¶ˆæ¯é˜Ÿåˆ—é›†æˆæµ‹è¯•

```javascript
describe('Workflow Engine Integration', () => {
  let workflowEngine;
  let messageQueue;
  let database;

  beforeEach(async () => {
    // è®¾ç½®æµ‹è¯•ç¯å¢ƒ
    workflowEngine = container.resolve('workflowEngine');
    messageQueue = container.resolve('messageQueue');
    database = container.resolve('database');
  });

  it('should execute user registration workflow', async () => {
    // å®šä¹‰å·¥ä½œæµ
    const workflowDefinition = {
      name: 'User Registration Workflow',
      tasks: [
        {
          id: 'validate_email',
          type: 'http',
          method: 'POST',
          url: '/api/email/verify',
          dependencies: []
        },
        {
          id: 'create_user_profile',
          type: 'script',
          script: 'await createUserProfile(context.userData)',
          dependencies: ['validate_email']
        },
        {
          id: 'send_welcome_email',
          type: 'http',
          method: 'POST',
          url: '/api/email/welcome',
          dependencies: ['create_user_profile']
        }
      ]
    };

    // åˆ›å»ºå·¥ä½œæµ
    const workflowId = await workflowEngine.createWorkflow(workflowDefinition);

    // ç›‘å¬å·¥ä½œæµå®Œæˆäº‹ä»¶
    const workflowCompleted = new Promise((resolve) => {
      messageQueue.subscribe('workflow.completed', (event) => {
        if (event.workflowId === workflowId) {
          resolve(event);
        }
      });
    });

    // å¯åŠ¨å·¥ä½œæµ
    const executionId = await workflowEngine.startWorkflow(workflowId, {
      userData: {
        email: 'john@example.com',
        name: 'John Doe'
      }
    });

    // ç­‰å¾…å·¥ä½œæµå®Œæˆ
    const completionEvent = await workflowCompleted;

    // éªŒè¯ç»“æœ
    expect(completionEvent.workflowId).toBe(workflowId);
    expect(completionEvent.status).toBe('completed');
    expect(completionEvent.tasksCompleted).toBe(3);

    // éªŒè¯æ•°æ®åº“çŠ¶æ€
    const workflow = await database.workflows.findById(workflowId);
    expect(workflow.status).toBe('completed');
    expect(workflow.tasks.length).toBe(3);
    expect(workflow.tasks.every(task => task.status === 'completed')).toBe(true);
  });

  it('should handle workflow failures gracefully', async () => {
    // åˆ›å»ºä¼šå¤±è´¥çš„å·¥ä½œæµ
    const failingWorkflow = {
      name: 'Failing Workflow',
      tasks: [
        {
          id: 'failing_task',
          type: 'http',
          method: 'POST',
          url: '/api/nonexistent', // è¿™ä¸ªè¯·æ±‚ä¼šå¤±è´¥
          dependencies: []
        }
      ]
    };

    const workflowId = await workflowEngine.createWorkflow(failingWorkflow);

    // ç›‘å¬å¤±è´¥äº‹ä»¶
    const workflowFailed = new Promise((resolve) => {
      messageQueue.subscribe('workflow.failed', (event) => {
        if (event.workflowId === workflowId) {
          resolve(event);
        }
      });
    });

    // å¯åŠ¨å·¥ä½œæµ
    await workflowEngine.startWorkflow(workflowId, {});

    // ç­‰å¾…å¤±è´¥
    const failureEvent = await workflowFailed;

    // éªŒè¯å¤±è´¥å¤„ç†
    expect(failureEvent.workflowId).toBe(workflowId);
    expect(failureEvent.status).toBe('failed');
    expect(failureEvent.error).toBeDefined();

    // éªŒè¯æ•°æ®åº“çŠ¶æ€
    const workflow = await database.workflows.findById(workflowId);
    expect(workflow.status).toBe('failed');
    expect(workflow.error).toBeDefined();
  });
});
```

## ğŸŒ ç«¯åˆ°ç«¯æµ‹è¯•

### åŠŸèƒ½ç‰¹æ€§

- **å®Œæ•´ç”¨æˆ·æµç¨‹**: ä»ç”¨æˆ·ç•Œé¢åˆ°åç«¯çš„å…¨é“¾è·¯æµ‹è¯•
- **æµè§ˆå™¨è‡ªåŠ¨åŒ–**: ä½¿ç”¨ Playwright è¿›è¡Œæµè§ˆå™¨æ“ä½œ
- **APIæµ‹è¯•**: RESTful API å’Œ GraphQL æ¥å£æµ‹è¯•
- **è·¨å¹³å°å…¼å®¹**: å¤šæµè§ˆå™¨å’Œè®¾å¤‡æ”¯æŒ
- **è§†è§‰å›å½’**: ç•Œé¢æˆªå›¾å¯¹æ¯”å’Œè§†è§‰æµ‹è¯•

### Playwright é…ç½®

```javascript
// playwright.config.js
import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './tests/e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: devices['iPhone 12'],
    },
  ],

  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});
```

### ç”¨æˆ·æ³¨å†Œæµç¨‹æµ‹è¯•

```javascript
import { test, expect } from '@playwright/test';

test.describe('User Registration Flow', () => {
  test.beforeEach(async ({ page }) => {
    // æ¸…ç†æµ‹è¯•æ•°æ®
    await page.goto('/admin/cleanup');
    await page.click('text=æ¸…ç†æµ‹è¯•æ•°æ®');
  });

  test('should complete full user registration flow', async ({ page }) => {
    // è®¿é—®æ³¨å†Œé¡µé¢
    await page.goto('/register');

    // å¡«å†™æ³¨å†Œè¡¨å•
    await page.fill('[data-testid="username"]', 'johndoe');
    await page.fill('[data-testid="email"]', 'john@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.fill('[data-testid="confirm-password"]', 'password123');

    // å‹¾é€‰åŒæ„æ¡æ¬¾
    await page.check('[data-testid="terms-agreement"]');

    // æäº¤è¡¨å•
    await page.click('[data-testid="register-button"]');

    // ç­‰å¾…é¡µé¢è·³è½¬åˆ°é‚®ç®±éªŒè¯é¡µé¢
    await page.waitForURL('/verify-email');

    // éªŒè¯æ˜¾ç¤ºæ­£ç¡®çš„æç¤ºä¿¡æ¯
    await expect(page.locator('[data-testid="verification-message"]'))
      .toContainText('éªŒè¯é‚®ä»¶å·²å‘é€åˆ° john@example.com');

    // æ¨¡æ‹Ÿç‚¹å‡»é‚®ä»¶ä¸­çš„éªŒè¯é“¾æ¥
    // æ³¨æ„ï¼šå®é™…æµ‹è¯•ä¸­éœ€è¦é€šè¿‡APIæˆ–é‚®ä»¶æœåŠ¡è·å–éªŒè¯é“¾æ¥
    const verificationLink = await getVerificationLinkFromEmail('john@example.com');
    await page.goto(verificationLink);

    // éªŒè¯è·³è½¬åˆ°ç™»å½•é¡µé¢
    await page.waitForURL('/login');

    // éªŒè¯æˆåŠŸæ¶ˆæ¯
    await expect(page.locator('[data-testid="success-message"]'))
      .toContainText('é‚®ç®±éªŒè¯æˆåŠŸï¼Œè¯·ç™»å½•');

    // å°è¯•ç™»å½•
    await page.fill('[data-testid="login-email"]', 'john@example.com');
    await page.fill('[data-testid="login-password"]', 'password123');
    await page.click('[data-testid="login-button"]');

    // éªŒè¯ç™»å½•æˆåŠŸå¹¶è·³è½¬åˆ°ç”¨æˆ·ä»ªè¡¨æ¿
    await page.waitForURL('/dashboard');

    // éªŒè¯ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤ºæ­£ç¡®
    await expect(page.locator('[data-testid="user-greeting"]'))
      .toContainText('æ¬¢è¿, johndoe');

    // éªŒè¯ç”¨æˆ·èœå•å¯ç”¨
    await page.click('[data-testid="user-menu"]');
    await expect(page.locator('[data-testid="logout-button"]')).toBeVisible();
  });

  test('should handle registration validation errors', async ({ page }) => {
    await page.goto('/register');

    // å°è¯•æäº¤ç©ºè¡¨å•
    await page.click('[data-testid="register-button"]');

    // éªŒè¯é”™è¯¯æ¶ˆæ¯
    await expect(page.locator('[data-testid="username-error"]'))
      .toContainText('ç”¨æˆ·åä¸èƒ½ä¸ºç©º');
    await expect(page.locator('[data-testid="email-error"]'))
      .toContainText('é‚®ç®±ä¸èƒ½ä¸ºç©º');
    await expect(page.locator('[data-testid="password-error"]'))
      .toContainText('å¯†ç ä¸èƒ½ä¸ºç©º');

    // å¡«å†™æ— æ•ˆæ•°æ®
    await page.fill('[data-testid="email"]', 'invalid-email');
    await page.fill('[data-testid="password"]', '123');
    await page.click('[data-testid="register-button"]');

    // éªŒè¯æ ¼å¼é”™è¯¯
    await expect(page.locator('[data-testid="email-error"]'))
      .toContainText('é‚®ç®±æ ¼å¼ä¸æ­£ç¡®');
    await expect(page.locator('[data-testid="password-error"]'))
      .toContainText('å¯†ç é•¿åº¦ä¸èƒ½å°‘äº8ä½');
  });

  test('should prevent duplicate email registration', async ({ page }) => {
    // å…ˆæ³¨å†Œä¸€ä¸ªç”¨æˆ·
    await page.goto('/register');
    await page.fill('[data-testid="username"]', 'user1');
    await page.fill('[data-testid="email"]', 'duplicate@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.fill('[data-testid="confirm-password"]', 'password123');
    await page.check('[data-testid="terms-agreement"]');
    await page.click('[data-testid="register-button"]');

    // ç­‰å¾…æ³¨å†Œå®Œæˆ
    await page.waitForURL('/verify-email');

    // å°è¯•æ³¨å†Œç›¸åŒé‚®ç®±çš„ç”¨æˆ·
    await page.goto('/register');
    await page.fill('[data-testid="username"]', 'user2');
    await page.fill('[data-testid="email"]', 'duplicate@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.fill('[data-testid="confirm-password"]', 'password123');
    await page.check('[data-testid="terms-agreement"]');
    await page.click('[data-testid="register-button"]');

    // éªŒè¯é”™è¯¯æç¤º
    await expect(page.locator('[data-testid="error-message"]'))
      .toContainText('è¯¥é‚®ç®±å·²è¢«æ³¨å†Œ');
  });

  test('should handle email verification timeout', async ({ page }) => {
    // æ³¨å†Œç”¨æˆ·
    await page.goto('/register');
    await page.fill('[data-testid="username"]', 'timeoutuser');
    await page.fill('[data-testid="email"]', 'timeout@example.com');
    await page.fill('[data-testid="password"]', 'password123');
    await page.fill('[data-testid="confirm-password"]', 'password123');
    await page.check('[data-testid="terms-agreement"]');
    await page.click('[data-testid="register-button"]');

    await page.waitForURL('/verify-email');

    // ç­‰å¾…éªŒè¯é“¾æ¥è¿‡æœŸï¼ˆå‡è®¾24å°æ—¶ï¼‰
    // åœ¨æµ‹è¯•ç¯å¢ƒä¸­ï¼Œæˆ‘ä»¬å¯ä»¥é€šè¿‡ä¿®æ”¹ç³»ç»Ÿæ—¶é—´æˆ–mockæ¥æ¨¡æ‹Ÿ

    // å°è¯•è®¿é—®è¿‡æœŸçš„éªŒè¯é“¾æ¥
    const expiredLink = 'http://localhost:3000/verify?token=expired-token';
    await page.goto(expiredLink);

    // éªŒè¯æ˜¾ç¤ºè¿‡æœŸæç¤º
    await expect(page.locator('[data-testid="error-message"]'))
      .toContainText('éªŒè¯é“¾æ¥å·²è¿‡æœŸ');

    // éªŒè¯å¯ä»¥é‡æ–°å‘é€éªŒè¯é‚®ä»¶
    await page.click('[data-testid="resend-verification"]');
    await expect(page.locator('[data-testid="success-message"]'))
      .toContainText('éªŒè¯é‚®ä»¶å·²é‡æ–°å‘é€');
  });
});
```

### å·¥ä½œæµç®¡ç†ç•Œé¢æµ‹è¯•

```javascript
test.describe('Workflow Management', () => {
  test.beforeEach(async ({ page }) => {
    // ç™»å½•ç®¡ç†å‘˜è´¦æˆ·
    await page.goto('/login');
    await page.fill('[data-testid="email"]', 'admin@example.com');
    await page.fill('[data-testid="password"]', 'adminpass');
    await page.click('[data-testid="login-button"]');
    await page.waitForURL('/admin');
  });

  test('should create and execute workflow', async ({ page }) => {
    // è¿›å…¥å·¥ä½œæµç®¡ç†é¡µé¢
    await page.goto('/admin/workflows');

    // ç‚¹å‡»åˆ›å»ºå·¥ä½œæµæŒ‰é’®
    await page.click('[data-testid="create-workflow-button"]');

    // å¡«å†™å·¥ä½œæµåŸºæœ¬ä¿¡æ¯
    await page.fill('[data-testid="workflow-name"]', 'æµ‹è¯•å·¥ä½œæµ');
    await page.fill('[data-testid="workflow-description"]', 'ç”¨äºç«¯åˆ°ç«¯æµ‹è¯•çš„å·¥ä½œæµ');

    // æ·»åŠ ä»»åŠ¡
    await page.click('[data-testid="add-task-button"]');

    // é…ç½®ç¬¬ä¸€ä¸ªä»»åŠ¡
    await page.fill('[data-testid="task-0-name"]', 'å‘é€é€šçŸ¥');
    await page.selectOption('[data-testid="task-0-type"]', 'http');
    await page.selectOption('[data-testid="task-0-method"]', 'POST');
    await page.fill('[data-testid="task-0-url"]', 'http://api.example.com/notify');

    // æ·»åŠ ç¬¬äºŒä¸ªä»»åŠ¡
    await page.click('[data-testid="add-task-button"]');
    await page.fill('[data-testid="task-1-name"]', 'æ›´æ–°æ•°æ®åº“');
    await page.selectOption('[data-testid="task-1-type"]', 'script');
    await page.fill('[data-testid="task-1-script"]',
      'await database.update({ status: "completed" })');

    // è®¾ç½®ä»»åŠ¡ä¾èµ–
    await page.click('[data-testid="task-1-depends-0"]'); // ä»»åŠ¡1ä¾èµ–ä»»åŠ¡0

    // ä¿å­˜å·¥ä½œæµ
    await page.click('[data-testid="save-workflow-button"]');

    // éªŒè¯å·¥ä½œæµåˆ›å»ºæˆåŠŸ
    await expect(page.locator('[data-testid="workflow-list"]'))
      .toContainText('æµ‹è¯•å·¥ä½œæµ');

    // æ‰§è¡Œå·¥ä½œæµ
    await page.click('[data-testid="execute-workflow-button"]');

    // ç­‰å¾…æ‰§è¡Œå®Œæˆ
    await page.waitForSelector('[data-testid="execution-completed"]');

    // éªŒè¯æ‰§è¡Œç»“æœ
    await expect(page.locator('[data-testid="task-0-status"]'))
      .toContainText('å®Œæˆ');
    await expect(page.locator('[data-testid="task-1-status"]'))
      .toContainText('å®Œæˆ');

    // æ£€æŸ¥æ‰§è¡Œæ—¥å¿—
    await page.click('[data-testid="view-logs-button"]');
    await expect(page.locator('[data-testid="execution-log"]'))
      .toContainText('å·¥ä½œæµæ‰§è¡ŒæˆåŠŸ');
  });

  test('should handle workflow execution failures', async ({ page }) => {
    // åˆ›å»ºä¼šå¤±è´¥çš„å·¥ä½œæµ
    await page.goto('/admin/workflows');
    await page.click('[data-testid="create-workflow-button"]');

    await page.fill('[data-testid="workflow-name"]', 'å¤±è´¥æµ‹è¯•å·¥ä½œæµ');
    await page.fill('[data-testid="workflow-description"]', 'æµ‹è¯•å·¥ä½œæµå¤±è´¥å¤„ç†');

    // æ·»åŠ ä¼šå¤±è´¥çš„ä»»åŠ¡
    await page.click('[data-testid="add-task-button"]');
    await page.fill('[data-testid="task-0-name"]', 'è°ƒç”¨å¤±è´¥API');
    await page.selectOption('[data-testid="task-0-type"]', 'http');
    await page.selectOption('[data-testid="task-0-method"]', 'GET');
    await page.fill('[data-testid="task-0-url"]', 'http://nonexistent-api.com/fail');

    await page.click('[data-testid="save-workflow-button"]');

    // æ‰§è¡Œå·¥ä½œæµ
    await page.click('[data-testid="execute-workflow-button"]');

    // ç­‰å¾…æ‰§è¡Œå¤±è´¥
    await page.waitForSelector('[data-testid="execution-failed"]');

    // éªŒè¯å¤±è´¥çŠ¶æ€
    await expect(page.locator('[data-testid="workflow-status"]'))
      .toContainText('å¤±è´¥');
    await expect(page.locator('[data-testid="task-0-status"]'))
      .toContainText('å¤±è´¥');

    // æ£€æŸ¥é”™è¯¯è¯¦æƒ…
    await page.click('[data-testid="view-error-details"]');
    await expect(page.locator('[data-testid="error-message"]'))
      .toContainText('è¿æ¥å¤±è´¥');

    // éªŒè¯é‡è¯•åŠŸèƒ½
    await page.click('[data-testid="retry-workflow-button"]');
    await page.waitForSelector('[data-testid="execution-completed"]');

    // éªŒè¯é‡è¯•æˆåŠŸï¼ˆå¦‚æœAPIæ¢å¤ï¼‰
    // æ³¨æ„ï¼šå®é™…æµ‹è¯•ä¸­å¯èƒ½éœ€è¦mock APIå“åº”
  });

  test('should monitor workflow performance', async ({ page }) => {
    await page.goto('/admin/workflows');

    // æ‰§è¡Œå¤šä¸ªå·¥ä½œæµ
    for (let i = 0; i < 5; i++) {
      await page.click('[data-testid="execute-workflow-button"]');
      await page.waitForSelector('[data-testid="execution-completed"]');
    }

    // æ£€æŸ¥æ€§èƒ½æŒ‡æ ‡
    await page.click('[data-testid="performance-tab"]');

    // éªŒè¯å¹³å‡æ‰§è¡Œæ—¶é—´
    const avgTime = await page.locator('[data-testid="avg-execution-time"]').textContent();
    expect(parseFloat(avgTime)).toBeLessThan(5000); // å¹³å‡æ‰§è¡Œæ—¶é—´åº”å°äº5ç§’

    // éªŒè¯æˆåŠŸç‡
    const successRate = await page.locator('[data-testid="success-rate"]').textContent();
    expect(parseFloat(successRate)).toBeGreaterThan(95); // æˆåŠŸç‡åº”å¤§äº95%

    // æ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ
    await expect(page.locator('[data-testid="memory-usage"]'))
      .toContainText('MB'); // åº”æ˜¾ç¤ºå†…å­˜ä½¿ç”¨é‡
    await expect(page.locator('[data-testid="cpu-usage"]'))
      .toContainText('%'); // åº”æ˜¾ç¤ºCPUä½¿ç”¨ç‡
  });
});
```

## âš¡ æ€§èƒ½æµ‹è¯•

### åŠŸèƒ½ç‰¹æ€§

- **è´Ÿè½½æµ‹è¯•**: æ¨¡æ‹Ÿé«˜å¹¶å‘ç”¨æˆ·è®¿é—®
- **å‹åŠ›æµ‹è¯•**: æŒç»­é«˜è´Ÿè½½ä¸‹çš„ç³»ç»Ÿè¡¨ç°
- **å®¹é‡æµ‹è¯•**: ç¡®å®šç³»ç»Ÿæœ€å¤§æ‰¿è½½èƒ½åŠ›
- **åŸºå‡†æµ‹è¯•**: ä¸ç«äº‰äº§å“è¿›è¡Œæ€§èƒ½å¯¹æ¯”
- **å†…å­˜æ³„æ¼æ£€æµ‹**: é•¿æ—¶é—´è¿è¡Œä¸‹çš„å†…å­˜ä½¿ç”¨ç›‘æ§

### è´Ÿè½½æµ‹è¯•é…ç½®

```javascript
// loadtest.config.js
export default {
  // æµ‹è¯•ç›®æ ‡
  url: 'http://localhost:3000',

  // å¹¶å‘ç”¨æˆ·æ•°
  maxConcurrentUsers: 100,

  // æ€»è¯·æ±‚æ•°
  totalRequests: 10000,

  // è¯·æ±‚é—´éš” (æ¯«ç§’)
  requestDelay: 100,

  // æµ‹è¯•æŒç»­æ—¶é—´ (åˆ†é’Ÿ)
  duration: 5,

  // æ¸è¿›å¼è´Ÿè½½
  rampUp: {
    enabled: true,
    duration: 60, // 1åˆ†é’Ÿå†…é€æ­¥å¢åŠ åˆ°æœ€å¤§å¹¶å‘
  },

  // æ–­è¨€æ¡ä»¶
  assertions: {
    responseTime: {
      max: 2000, // æœ€å¤§å“åº”æ—¶é—´2ç§’
    },
    errorRate: {
      max: 0.05, // æœ€å¤§é”™è¯¯ç‡5%
    },
    throughput: {
      min: 50, // æœ€å°æ¯ç§’è¯·æ±‚æ•°
    }
  }
};
```

### API æ€§èƒ½æµ‹è¯•

```javascript
import { check } from 'k6';
import http from 'k6/http';

export let options = {
  stages: [
    { duration: '1m', target: 10 },   // 1åˆ†é’Ÿå†…å¢åŠ åˆ°10ç”¨æˆ·
    { duration: '3m', target: 50 },   // 3åˆ†é’Ÿå†…å¢åŠ åˆ°50ç”¨æˆ·
    { duration: '1m', target: 100 },  // 1åˆ†é’Ÿå†…å¢åŠ åˆ°100ç”¨æˆ·
    { duration: '2m', target: 100 },  // ä¿æŒ100ç”¨æˆ·2åˆ†é’Ÿ
    { duration: '1m', target: 0 },    // 1åˆ†é’Ÿå†…é™åˆ°0ç”¨æˆ·
  ],
  thresholds: {
    http_req_duration: ['p(95)<2000'], // 95%çš„è¯·æ±‚å“åº”æ—¶é—´å°äº2ç§’
    http_req_failed: ['rate<0.05'],    // é”™è¯¯ç‡å°äº5%
  },
};

const BASE_URL = __ENV.BASE_URL || 'http://localhost:3000';

export default function () {
  // ç”¨æˆ·æ³¨å†ŒAPIæµ‹è¯•
  const registerPayload = JSON.stringify({
    username: `user_${__VU}_${Date.now()}`, // ä½¿ç”¨VU IDå’Œæ—¶é—´æˆ³ä¿è¯å”¯ä¸€æ€§
    email: `user_${__VU}_${Date.now()}@example.com`,
    password: 'password123'
  });

  const registerResponse = http.post(`${BASE_URL}/api/users`, registerPayload, {
    headers: {
      'Content-Type': 'application/json',
    },
  });

  check(registerResponse, {
    'register status is 201': (r) => r.status === 201,
    'register response time < 1000ms': (r) => r.timings.duration < 1000,
    'register response has user id': (r) => r.json().hasOwnProperty('id'),
  });

  // ç”¨æˆ·ç™»å½•APIæµ‹è¯•
  const loginPayload = JSON.stringify({
    email: `user_${__VU}_${Date.now()}@example.com`,
    password: 'password123'
  });

  const loginResponse = http.post(`${BASE_URL}/api/auth/login`, loginPayload, {
    headers: {
      'Content-Type': 'application/json',
    },
  });

  check(loginResponse, {
    'login status is 200': (r) => r.status === 200,
    'login response time < 500ms': (r) => r.timings.duration < 500,
    'login response has token': (r) => r.json().hasOwnProperty('token'),
  });

  const token = loginResponse.json().token;

  // è·å–ç”¨æˆ·ä¿¡æ¯APIæµ‹è¯•
  const userResponse = http.get(`${BASE_URL}/api/users/profile`, {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json',
    },
  });

  check(userResponse, {
    'get profile status is 200': (r) => r.status === 200,
    'get profile response time < 300ms': (r) => r.timings.duration < 300,
  });

  // æ¨¡æ‹Ÿç”¨æˆ·æ€è€ƒæ—¶é—´
  const thinkingTime = Math.random() * 1000 + 500; // 500ms åˆ° 1500ms ä¹‹é—´
  sleep(thinkingTime / 1000);
}

export function handleSummary(data) {
  return {
    'stdout': textSummary(data, { indent: ' ', enableColors: true }),
    'performance-report.json': JSON.stringify(data, null, 2),
    'performance-report.html': htmlReport(data),
  };
}
```

### æ•°æ®åº“æ€§èƒ½æµ‹è¯•

```javascript
describe('Database Performance Tests', () => {
  let database;
  let testData;

  beforeAll(async () => {
    database = createDatabaseConnection();
    testData = await generateTestData(10000); // ç”Ÿæˆ10000æ¡æµ‹è¯•æ•°æ®
  });

  afterAll(async () => {
    await database.close();
  });

  test('should handle high concurrency user queries', async () => {
    const startTime = Date.now();
    const promises = [];

    // å¹¶å‘æ‰§è¡Œ100ä¸ªæŸ¥è¯¢
    for (let i = 0; i < 100; i++) {
      promises.push(database.users.findById(testData[i].id));
    }

    const results = await Promise.all(promises);
    const duration = Date.now() - startTime;

    // éªŒè¯æ‰€æœ‰æŸ¥è¯¢æˆåŠŸ
    expect(results.length).toBe(100);
    results.forEach(result => {
      expect(result).toBeDefined();
    });

    // éªŒè¯æ€§èƒ½
    expect(duration).toBeLessThan(5000); // 5ç§’å†…å®Œæˆ
    console.log(`100 concurrent queries took ${duration}ms`);
  });

  test('should handle bulk insert operations', async () => {
    const bulkData = generateBulkInsertData(1000);

    const startTime = Date.now();
    const result = await database.users.insertMany(bulkData);
    const duration = Date.now() - startTime;

    expect(result.insertedCount).toBe(1000);
    expect(duration).toBeLessThan(10000); // 10ç§’å†…å®Œæˆ

    console.log(`Bulk insert of 1000 records took ${duration}ms`);
  });

  test('should maintain performance under sustained load', async () => {
    const durations = [];

    // æŒç»­è¿è¡Œ5åˆ†é’Ÿ
    const endTime = Date.now() + 5 * 60 * 1000;

    while (Date.now() < endTime) {
      const startTime = Date.now();

      // æ‰§è¡Œä¸€ä¸ªå…¸å‹çš„æŸ¥è¯¢
      await database.users.find({ status: 'active' }).limit(100);

      const duration = Date.now() - startTime;
      durations.push(duration);

      // çŸ­æš‚ä¼‘æ¯ï¼Œé¿å…è¿‡åº¦è´Ÿè½½
      await sleep(100);
    }

    // åˆ†ææ€§èƒ½æ•°æ®
    const avgDuration = durations.reduce((a, b) => a + b, 0) / durations.length;
    const maxDuration = Math.max(...durations);
    const p95Duration = calculatePercentile(durations, 95);

    console.log(`Performance over 5 minutes:
      Average: ${avgDuration}ms
      Max: ${maxDuration}ms
      95th percentile: ${p95Duration}ms`);

    // éªŒè¯æ€§èƒ½ç¨³å®š
    expect(avgDuration).toBeLessThan(200);
    expect(p95Duration).toBeLessThan(500);
    expect(maxDuration).toBeLessThan(2000);
  });

  test('should handle complex queries efficiently', async () => {
    // åˆ›å»ºå¤åˆç´¢å¼•ï¼ˆå¦‚æœéœ€è¦ï¼‰
    await database.users.createIndex({
      status: 1,
      createdAt: -1,
      department: 1
    });

    const queries = [
      { status: 'active' },
      { department: 'IT', status: 'active' },
      { createdAt: { $gte: new Date('2024-01-01') } },
      {
        $and: [
          { department: 'IT' },
          { status: 'active' },
          { createdAt: { $gte: new Date('2024-01-01') } }
        ]
      }
    ];

    for (const query of queries) {
      const startTime = Date.now();
      const result = await database.users.find(query).explain('executionStats');
      const duration = Date.now() - startTime;

      console.log(`Query: ${JSON.stringify(query)}
        Execution time: ${duration}ms
        Documents examined: ${result.executionStats.totalDocsExamined}
        Documents returned: ${result.executionStats.totalDocsReturned}`);

      // éªŒè¯æŸ¥è¯¢æ€§èƒ½
      expect(duration).toBeLessThan(1000);
      expect(result.executionStats.totalDocsExamined).toBeLessThan(10000);
    }
  });

  function calculatePercentile(values, percentile) {
    const sorted = values.sort((a, b) => a - b);
    const index = Math.ceil((percentile / 100) * sorted.length) - 1;
    return sorted[index];
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
});
```

## ğŸ”’ å®‰å…¨æµ‹è¯•

### åŠŸèƒ½ç‰¹æ€§

- **èº«ä»½éªŒè¯æµ‹è¯•**: ç™»å½•ã€æ³¨å†Œã€å¯†ç é‡ç½®
- **æˆæƒæµ‹è¯•**: è§’è‰²æƒé™ã€è®¿é—®æ§åˆ¶
- **è¾“å…¥éªŒè¯æµ‹è¯•**: SQLæ³¨å…¥ã€XSSã€CSRF
- **åŠ å¯†æµ‹è¯•**: å¯†ç å“ˆå¸Œã€æ•°æ®åŠ å¯†
- **ä¼šè¯ç®¡ç†æµ‹è¯•**: ä¼šè¯å›ºå®šã€å¹¶å‘ç™»å½•

### èº«ä»½éªŒè¯å®‰å…¨æµ‹è¯•

```javascript
describe('Authentication Security Tests', () => {
  let app;
  let agent;

  beforeAll(async () => {
    app = createTestApp();
    agent = request.agent(app);
  });

  test('should prevent brute force attacks', async () => {
    const email = 'victim@example.com';
    const wrongPassword = 'wrongpassword';

    // å°è¯•å¤šæ¬¡é”™è¯¯ç™»å½•
    for (let i = 0; i < 10; i++) {
      const response = await agent
        .post('/api/auth/login')
        .send({ email, password: wrongPassword })
        .expect(401);

      // å‰å‡ æ¬¡åº”è¯¥è¿”å›æ­£å¸¸é”™è¯¯
      if (i < 5) {
        expect(response.body.message).toBe('Invalid credentials');
      } else {
        // ä¹‹ååº”è¯¥è¢«é™æµ
        expect(response.status).toBe(429); // Too Many Requests
        expect(response.body.message).toContain('Too many failed attempts');
      }
    }
  });

  test('should handle password reset securely', async () => {
    const email = 'user@example.com';

    // è¯·æ±‚å¯†ç é‡ç½®
    const resetResponse = await agent
      .post('/api/auth/forgot-password')
      .send({ email })
      .expect(200);

    expect(resetResponse.body.message).toContain('Reset email sent');

    // éªŒè¯é‡ç½®ä»¤ç‰Œ
    const resetToken = await getResetTokenFromEmail(email); // ä»é‚®ä»¶ä¸­æå–ä»¤ç‰Œ
    expect(resetToken).toBeDefined();

    // ä½¿ç”¨ä»¤ç‰Œé‡ç½®å¯†ç 
    const newPassword = 'newSecurePassword123!';
    await agent
      .post('/api/auth/reset-password')
      .send({
        token: resetToken,
        password: newPassword,
        confirmPassword: newPassword
      })
      .expect(200);

    // éªŒè¯æ–°å¯†ç å¯ä»¥ç™»å½•
    const loginResponse = await agent
      .post('/api/auth/login')
      .send({ email, password: newPassword })
      .expect(200);

    expect(loginResponse.body.token).toBeDefined();

    // éªŒè¯æ—§ä»¤ç‰Œå¤±æ•ˆ
    await agent
      .post('/api/auth/reset-password')
      .send({
        token: resetToken, // ä½¿ç”¨å·²ä½¿ç”¨çš„ä»¤ç‰Œ
        password: 'anotherPassword123!',
        confirmPassword: 'anotherPassword123!'
      })
      .expect(400);
  });

  test('should prevent session fixation attacks', async () => {
    // ç”¨æˆ·1ç™»å½•
    const login1 = await agent
      .post('/api/auth/login')
      .send({ email: 'user1@example.com', password: 'password1' });

    const sessionId1 = login1.body.sessionId;

    // æ¨¡æ‹Ÿä¼šè¯å›ºå®šæ”»å‡»ï¼šæ”»å‡»è€…è®¾ç½®sessionId
    const fixedSessionId = 'fixed-session-id-12345';

    // æ”»å‡»è€…è¯±å¯¼ç”¨æˆ·ä½¿ç”¨å›ºå®šsessionIdç™»å½•
    const login2 = await request(app)
      .post('/api/auth/login')
      .set('Cookie', `sessionId=${fixedSessionId}`)
      .send({ email: 'user2@example.com', password: 'password2' });

    // ç³»ç»Ÿåº”è¯¥ç”Ÿæˆæ–°çš„sessionIdï¼Œè€Œä¸æ˜¯ä½¿ç”¨æ”»å‡»è€…æä¾›çš„
    expect(login2.body.sessionId).not.toBe(fixedSessionId);
    expect(login2.body.sessionId).toBeDefined();
  });

  test('should handle concurrent login sessions', async () => {
    const email = 'user@example.com';
    const password = 'password123';
    const maxSessions = 3; // å‡è®¾æœ€å¤§å…è®¸3ä¸ªå¹¶å‘ä¼šè¯

    // åˆ›å»ºå¤šä¸ªå¹¶å‘ä¼šè¯
    const loginPromises = [];
    for (let i = 0; i < maxSessions + 2; i++) {
      loginPromises.push(
        request(app)
          .post('/api/auth/login')
          .send({ email, password })
      );
    }

    const responses = await Promise.all(loginPromises);

    // å‰maxSessionsä¸ªåº”è¯¥æˆåŠŸ
    for (let i = 0; i < maxSessions; i++) {
      expect(responses[i].status).toBe(200);
      expect(responses[i].body.token).toBeDefined();
    }

    // è¶…å‡ºé™åˆ¶çš„åº”è¯¥å¤±è´¥
    for (let i = maxSessions; i < responses.length; i++) {
      expect(responses[i].status).toBe(403);
      expect(responses[i].body.message).toContain('Maximum sessions exceeded');
    }
  });

  test('should validate JWT token integrity', async () => {
    // ç™»å½•è·å–æœ‰æ•ˆä»¤ç‰Œ
    const loginResponse = await agent
      .post('/api/auth/login')
      .send({ email: 'user@example.com', password: 'password123' })
      .expect(200);

    const validToken = loginResponse.body.token;

    // ç¯¡æ”¹ä»¤ç‰Œ
    const tamperedToken = tamperWithJWT(validToken);

    // ä½¿ç”¨ç¯¡æ”¹çš„ä»¤ç‰Œè®¿é—®å—ä¿æŠ¤èµ„æº
    await agent
      .get('/api/users/profile')
      .set('Authorization', `Bearer ${tamperedToken}`)
      .expect(401);

    // éªŒè¯é”™è¯¯æ¶ˆæ¯
    const errorResponse = await agent
      .get('/api/users/profile')
      .set('Authorization', `Bearer ${tamperedToken}`);

    expect(errorResponse.body.message).toContain('Invalid token');
  });

  test('should implement secure logout', async () => {
    // ç™»å½•
    const loginResponse = await agent
      .post('/api/auth/login')
      .send({ email: 'user@example.com', password: 'password123' })
      .expect(200);

    const token = loginResponse.body.token;
    const sessionId = loginResponse.body.sessionId;

    // éªŒè¯ä»¤ç‰Œæœ‰æ•ˆ
    await agent
      .get('/api/users/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // ç™»å‡º
    await agent
      .post('/api/auth/logout')
      .set('Authorization', `Bearer ${token}`)
      .expect(200);

    // éªŒè¯ä»¤ç‰Œå·²å¤±æ•ˆ
    await agent
      .get('/api/users/profile')
      .set('Authorization', `Bearer ${token}`)
      .expect(401);

    // éªŒè¯ä¼šè¯å·²æ¸…ç†
    const sessionCheck = await app.locals.sessionStore.get(sessionId);
    expect(sessionCheck).toBeNull();
  });
});

// è¾…åŠ©å‡½æ•°
function tamperWithJWT(token) {
  // ç®€å•çš„ä»¤ç‰Œç¯¡æ”¹ï¼šä¿®æ”¹payloadéƒ¨åˆ†
  const parts = token.split('.');
  if (parts.length !== 3) return token;

  const header = parts[0];
  const payload = JSON.parse(Buffer.from(parts[1], 'base64').toString());

  // ä¿®æ”¹ç”¨æˆ·è§’è‰²
  payload.role = 'admin';

  const tamperedPayload = Buffer.from(JSON.stringify(payload)).toString('base64');
  const tamperedToken = `${header}.${tamperedPayload}.${parts[2]}`;

  return tamperedToken;
}

async function getResetTokenFromEmail(email) {
  // åœ¨æµ‹è¯•ç¯å¢ƒä¸­ï¼Œä»å†…å­˜é˜Ÿåˆ—æˆ–æ•°æ®åº“ä¸­è·å–é‡ç½®ä»¤ç‰Œ
  // å®é™…å®ç°å–å†³äºé‚®ä»¶æœåŠ¡å’Œæµ‹è¯•ç¯å¢ƒè®¾ç½®
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve('test-reset-token-12345');
    }, 100);
  });
}
```

### è¾“å…¥éªŒè¯å®‰å…¨æµ‹è¯•

```javascript
describe('Input Validation Security Tests', () => {
  let app;

  beforeAll(async () => {
    app = createTestApp();
  });

  describe('SQL Injection Prevention', () => {
    test('should prevent SQL injection in login', async () => {
      const maliciousInputs = [
        "' OR '1'='1",
        "'; DROP TABLE users; --",
        "' UNION SELECT * FROM users --",
        "admin' --",
        "' OR 1=1 --"
      ];

      for (const maliciousInput of maliciousInputs) {
        const response = await request(app)
          .post('/api/auth/login')
          .send({
            email: maliciousInput,
            password: 'password123'
          })
          .expect(401);

        // åº”è¯¥åªæ˜¯è®¤è¯å¤±è´¥ï¼Œè€Œä¸æ˜¯SQLé”™è¯¯
        expect(response.body.message).toBe('Invalid credentials');
        expect(response.body.message).not.toContain('SQL');
        expect(response.body.message).not.toContain('syntax');
      }
    });

    test('should prevent SQL injection in user search', async () => {
      const maliciousQueries = [
        "'; DROP TABLE users; --",
        "' UNION SELECT password FROM users --",
        "1' OR '1'='1",
        "admin'; UPDATE users SET role='admin"
      ];

      for (const maliciousQuery of maliciousQueries) {
        const response = await request(app)
          .get('/api/users/search')
          .query({ q: maliciousQuery })
          .expect(200);

        // éªŒè¯æ²¡æœ‰å‘ç”ŸSQLæ³¨å…¥
        expect(response.body).toBeDefined();
        // æ£€æŸ¥å“åº”ä¸åŒ…å«æ•æ„Ÿä¿¡æ¯
        expect(response.body).not.toHaveProperty('password');
      }
    });
  });

  describe('XSS Prevention', () => {
    test('should sanitize HTML input', async () => {
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<svg onload=alert("XSS")>'
      ];

      for (const payload of xssPayloads) {
        // åˆ›å»ºç”¨æˆ·æ—¶å°è¯•æ³¨å…¥XSS
        const response = await request(app)
          .post('/api/users')
          .send({
            username: 'testuser',
            email: 'test@example.com',
            password: 'password123',
            bio: payload // å°è¯•åœ¨bioå­—æ®µæ³¨å…¥XSS
          })
          .expect(201);

        // è·å–ç”¨æˆ·ä¿¡æ¯
        const profileResponse = await request(app)
          .get(`/api/users/${response.body.id}`)
          .expect(200);

        // éªŒè¯XSSä»£ç å·²è¢«è½¬ä¹‰æˆ–è¿‡æ»¤
        const bio = profileResponse.body.bio;
        expect(bio).not.toContain('<script>');
        expect(bio).not.toContain('javascript:');
        expect(bio).not.toContain('onerror');
        expect(bio).not.toContain('onload');
      }
    });

    test('should prevent XSS in query parameters', async () => {
      const xssParams = [
        '<script>alert("XSS")</script>',
        '"><script>alert("XSS")</script>',
        'javascript:alert("XSS")'
      ];

      for (const param of xssParams) {
        const response = await request(app)
          .get('/api/search')
          .query({ q: param })
          .expect(200);

        // éªŒè¯å“åº”ä¸åŒ…å«å¯æ‰§è¡Œçš„XSSä»£ç 
        expect(response.text).not.toContain('<script>');
        expect(response.text).not.toContain('javascript:');
      }
    });
  });

  describe('CSRF Protection', () => {
    test('should require CSRF token for state-changing operations', async () => {
      // ç™»å½•è·å–ä¼šè¯
      const agent = request.agent(app);
      await agent
        .post('/api/auth/login')
        .send({ email: 'user@example.com', password: 'password123' })
        .expect(200);

      // å°è¯•æ²¡æœ‰CSRFä»¤ç‰Œçš„POSTè¯·æ±‚
      await agent
        .post('/api/users/profile')
        .send({ bio: 'Updated bio' })
        .expect(403);

      // è·å–CSRFä»¤ç‰Œ
      const csrfResponse = await agent
        .get('/api/csrf-token')
        .expect(200);

      const csrfToken = csrfResponse.body.token;

      // ä½¿ç”¨CSRFä»¤ç‰Œçš„è¯·æ±‚åº”è¯¥æˆåŠŸ
      await agent
        .post('/api/users/profile')
        .set('X-CSRF-Token', csrfToken)
        .send({ bio: 'Updated bio' })
        .expect(200);
    });

    test('should validate CSRF token integrity', async () => {
      const agent = request.agent(app);
      await agent
        .post('/api/auth/login')
        .send({ email: 'user@example.com', password: 'password123' })
        .expect(200);

      // ä½¿ç”¨æ— æ•ˆçš„CSRFä»¤ç‰Œ
      await agent
        .post('/api/users/profile')
        .set('X-CSRF-Token', 'invalid-csrf-token')
        .send({ bio: 'Updated bio' })
        .expect(403);

      // ä½¿ç”¨è¿‡æœŸçš„CSRFä»¤ç‰Œ
      const expiredToken = generateExpiredCSRFToken();
      await agent
        .post('/api/users/profile')
        .set('X-CSRF-Token', expiredToken)
        .send({ bio: 'Updated bio' })
        .expect(403);
    });
  });

  describe('File Upload Security', () => {
    test('should validate file types', async () => {
      const maliciousFiles = [
        { name: 'malicious.exe', type: 'application/x-msdownload' },
        { name: 'script.php', type: 'application/x-php' },
        { name: 'webshell.jsp', type: 'application/jsp' },
        { name: 'malicious.html', type: 'text/html' }
      ];

      for (const file of maliciousFiles) {
        const response = await request(app)
          .post('/api/upload')
          .attach('file', Buffer.from('malicious content'), file)
          .expect(400);

        expect(response.body.message).toContain('File type not allowed');
      }
    });

    test('should prevent directory traversal', async () => {
      const traversalAttempts = [
        '../../../../etc/passwd',
        '..\\..\\..\\..\\windows\\system32\\config\\sam',
        '....//....//....//etc/passwd',
        '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd'
      ];

      for (const path of traversalAttempts) {
        const response = await request(app)
          .post('/api/upload')
          .attach('file', Buffer.from('test content'), {
            filename: path,
            contentType: 'text/plain'
          })
          .expect(400);

        expect(response.body.message).toContain('Invalid filename');
      }
    });

    test('should limit file size', async () => {
      // åˆ›å»ºè¶…è¿‡é™åˆ¶çš„æ–‡ä»¶ (å‡è®¾é™åˆ¶æ˜¯5MB)
      const largeFile = Buffer.alloc(6 * 1024 * 1024); // 6MB

      const response = await request(app)
        .post('/api/upload')
        .attach('file', largeFile, 'large-file.txt')
        .expect(413); // Payload Too Large

      expect(response.body.message).toContain('File too large');
    });

    test('should scan for malware', async () => {
      // åˆ›å»ºåŒ…å«æ¶æ„ç­¾åçš„æ–‡ä»¶
      const maliciousContent = Buffer.from('X5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*');

      const response = await request(app)
        .post('/api/upload')
        .attach('file', maliciousContent, 'eicar.txt')
        .expect(400);

      expect(response.body.message).toContain('Malware detected');
    });
  });

  describe('Rate Limiting', () => {
    test('should enforce API rate limits', async () => {
      const endpoint = '/api/users/search';
      const requests = [];

      // å‘é€å¤§é‡è¯·æ±‚
      for (let i = 0; i < 150; i++) { // å‡è®¾é™åˆ¶æ˜¯æ¯åˆ†é’Ÿ100æ¬¡
        requests.push(
          request(app)
            .get(endpoint)
            .query({ q: 'test' })
        );
      }

      const responses = await Promise.all(requests);

      // è®¡ç®—æˆåŠŸå’Œå¤±è´¥çš„è¯·æ±‚æ•°
      const successCount = responses.filter(r => r.status === 200).length;
      const rateLimitedCount = responses.filter(r => r.status === 429).length;

      expect(successCount).toBeGreaterThan(0);
      expect(rateLimitedCount).toBeGreaterThan(0);
      expect(successCount + rateLimitedCount).toBe(150);
    });

    test('should differentiate rate limits by endpoint', async () => {
      // å¯¹ä¸åŒçš„ç«¯ç‚¹åº”è¯¥æœ‰ä¸åŒçš„é™åˆ¶
      const endpoints = [
        { path: '/api/auth/login', limit: 5 },     // ç™»å½•é™åˆ¶ä¸¥æ ¼
        { path: '/api/users/search', limit: 100 }, // æœç´¢é™åˆ¶å®½æ¾
        { path: '/api/data/export', limit: 10 }    // å¯¼å‡ºé™åˆ¶ä¸­ç­‰
      ];

      for (const { path, limit } of endpoints) {
        const requests = [];

        // å‘é€è¶…å‡ºé™åˆ¶çš„è¯·æ±‚
        for (let i = 0; i < limit + 5; i++) {
          if (path === '/api/auth/login') {
            requests.push(
              request(app)
                .post(path)
                .send({ email: 'test@example.com', password: 'wrong' })
            );
          } else {
            requests.push(request(app).get(path));
          }
        }

        const responses = await Promise.all(requests);

        // å‰limitä¸ªè¯·æ±‚åº”è¯¥æˆåŠŸï¼Œæœ€åå‡ ä¸ªåº”è¯¥è¢«é™æµ
        const successCount = responses.filter(r => r.status !== 429).length;
        const rateLimitedCount = responses.filter(r => r.status === 429).length;

        expect(successCount).toBe(limit);
        expect(rateLimitedCount).toBe(5);
      }
    });
  });
});
```

## ğŸ“Š æµ‹è¯•æŠ¥å‘Šå’Œåˆ†æ

### æµ‹è¯•æŠ¥å‘Šç”Ÿæˆ

```javascript
// vitest.config.js - æµ‹è¯•æŠ¥å‘Šé…ç½®
import { defineConfig } from 'vitest/config';
import { coverageConfigDefaults } from 'vitest/config';

export default defineConfig({
  test: {
    coverage: {
      provider: 'istanbul',
      reporter: ['text', 'json', 'html', 'lcov'],
      exclude: [
        'node_modules/',
        'dist/',
        'test/',
        '**/*.config.js',
        '**/*.d.ts'
      ],
      thresholds: {
        global: {
          statements: 80,
          branches: 75,
          functions: 85,
          lines: 80
        },
        './src/core/': {
          statements: 90,
          branches: 85,
          functions: 95,
          lines: 90
        }
      },
      reportsDirectory: './coverage'
    },
    reporters: [
      'default',
      'json',
      'junit', // CI/CD å·¥å…·æ”¯æŒ
      'html'
    ],
    outputFile: {
      json: './test-results/test-results.json',
      junit: './test-results/junit.xml'
    }
  }
});
```

### è´¨é‡é—¨ç¦é…ç½®

```javascript
// quality-gate.config.js
export default {
  // è¦†ç›–ç‡é—¨ç¦
  coverage: {
    global: {
      statements: 80,
      branches: 75,
      functions: 85,
      lines: 80
    },
    // æ ¸å¿ƒæ¨¡å—è¦æ±‚æ›´é«˜
    './src/core/': {
      statements: 90,
      branches: 85,
      functions: 95,
      lines: 90
    }
  },

  // æ€§èƒ½é—¨ç¦
  performance: {
    maxResponseTime: 2000,    // æœ€å¤§å“åº”æ—¶é—´ (ms)
    maxMemoryUsage: 512,      // æœ€å¤§å†…å­˜ä½¿ç”¨ (MB)
    maxCpuUsage: 80,          // æœ€å¤§CPUä½¿ç”¨ç‡ (%)
    minThroughput: 100        // æœ€å°ååé‡ (req/sec)
  },

  // å®‰å…¨é—¨ç¦
  security: {
    maxVulnerabilities: 0,    // å…è®¸çš„æœ€å¤§æ¼æ´æ•°
    maxSeverity: 'medium',    // å…è®¸çš„æœ€å¤§æ¼æ´ä¸¥é‡ç¨‹åº¦
    requiredHeaders: [        // å¿…éœ€çš„å®‰å…¨å¤´
      'X-Content-Type-Options',
      'X-Frame-Options',
      'X-XSS-Protection',
      'Strict-Transport-Security'
    ]
  },

  // ä»£ç è´¨é‡é—¨ç¦
  codeQuality: {
    maxComplexity: 10,        // æœ€å¤§åœˆå¤æ‚åº¦
    maxLinesPerFunction: 50,  // å‡½æ•°æœ€å¤§è¡Œæ•°
    maxParameters: 4,         // å‡½æ•°æœ€å¤§å‚æ•°æ•°
    requireJSDoc: true        // è¦æ±‚JSDocæ³¨é‡Š
  }
};
```

### æŒç»­é›†æˆé›†æˆ

```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [16.x, 18.x, 20.x]

    steps:
    - uses: actions/checkout@v3

    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Run linting
      run: npm run lint

    - name: Run unit tests
      run: npm run test:unit

    - name: Run integration tests
      run: npm run test:integration

    - name: Run security tests
      run: npm run test:security

    - name: Generate coverage report
      run: npm run test:coverage

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info

    - name: Run performance tests
      run: npm run test:performance

    - name: Quality gate check
      run: npm run quality:check

  e2e:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v3

    - name: Setup Node.js
      uses: actions/setup-node@v3
      with:
        node-version: 18.x
        cache: 'npm'

    - name: Install dependencies
      run: npm ci

    - name: Start test environment
      run: |
        docker-compose -f docker-compose.test.yml up -d
        npm run wait-for-services

    - name: Run E2E tests
      run: npm run test:e2e

    - name: Upload test artifacts
      uses: actions/upload-artifact@v3
      if: failure()
      with:
        name: e2e-screenshots
        path: test-results/screenshots/

  security:
    runs-on: ubuntu-latest
    needs: test

    steps:
    - uses: actions/checkout@v3

    - name: Run security audit
      run: npm run security:audit

    - name: Run dependency vulnerability scan
      run: npm run security:scan

    - name: Upload security report
      uses: actions/upload-artifact@v3
      with:
        name: security-report
        path: security-report.json

  deploy:
    runs-on: ubuntu-latest
    needs: [test, e2e, security]
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Deploy to staging
      run: npm run deploy:staging

    - name: Run smoke tests
      run: npm run test:smoke

    - name: Deploy to production
      run: npm run deploy:production

    - name: Run production verification
      run: npm run verify:deployment
```

## ğŸ¯ æµ‹è¯•æœ€ä½³å®è·µ

### æµ‹è¯•ç»„ç»‡ç»“æ„

```
tests/
â”œâ”€â”€ unit/                          # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ core/                     # æ ¸å¿ƒæ¨¡å—æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ http.test.js
â”‚   â”‚   â”œâ”€â”€ auth.test.js
â”‚   â”‚   â”œâ”€â”€ state.test.js
â”‚   â”‚   â””â”€â”€ queue.test.js
â”‚   â”œâ”€â”€ services/                 # æœåŠ¡å±‚æµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ userService.test.js
â”‚   â”‚   â””â”€â”€ workflowEngine.test.js
â”‚   â””â”€â”€ utils/                    # å·¥å…·å‡½æ•°æµ‹è¯•
â”‚       â”œâ”€â”€ date.test.js
â”‚       â””â”€â”€ validation.test.js
â”œâ”€â”€ integration/                  # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ api/                      # APIé›†æˆæµ‹è¯•
â”‚   â”‚   â”œâ”€â”€ users.test.js
â”‚   â”‚   â””â”€â”€ workflows.test.js
â”‚   â”œâ”€â”€ database/                 # æ•°æ®åº“é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ messaging/                # æ¶ˆæ¯é˜Ÿåˆ—é›†æˆæµ‹è¯•
â”œâ”€â”€ e2e/                         # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ user-registration.spec.js
â”‚   â”œâ”€â”€ workflow-management.spec.js
â”‚   â””â”€â”€ admin-dashboard.spec.js
â”œâ”€â”€ performance/                  # æ€§èƒ½æµ‹è¯•
â”‚   â”œâ”€â”€ load/                     # è´Ÿè½½æµ‹è¯•
â”‚   â”œâ”€â”€ stress/                   # å‹åŠ›æµ‹è¯•
â”‚   â””â”€â”€ benchmark/                # åŸºå‡†æµ‹è¯•
â”œâ”€â”€ security/                     # å®‰å…¨æµ‹è¯•
â”‚   â”œâ”€â”€ authentication.test.js
â”‚   â”œâ”€â”€ authorization.test.js
â”‚   â”œâ”€â”€ input-validation.test.js
â”‚   â””â”€â”€ rate-limiting.test.js
â”œâ”€â”€ fixtures/                     # æµ‹è¯•æ•°æ®
â”‚   â”œâ”€â”€ users.json
â”‚   â”œâ”€â”€ workflows.json
â”‚   â””â”€â”€ sample-data.sql
â”œâ”€â”€ utils/                        # æµ‹è¯•å·¥å…·
â”‚   â”œâ”€â”€ test-helpers.js
â”‚   â”œâ”€â”€ mock-data.js
â”‚   â””â”€â”€ database-helpers.js
â””â”€â”€ config/                       # æµ‹è¯•é…ç½®
    â”œâ”€â”€ vitest.config.js
    â”œâ”€â”€ playwright.config.js
    â””â”€â”€ testcontainers.config.js
```

### æµ‹è¯•å‘½åçº¦å®š

```javascript
// å•å…ƒæµ‹è¯•æ–‡ä»¶å‘½å
// [æ¨¡å—å].test.js æˆ– [æ¨¡å—å].spec.js
// ä¾‹å¦‚ï¼šuserService.test.js, httpClient.test.js

// æµ‹è¯•ç”¨ä¾‹å‘½å
describe('UserService', () => {
  describe('createUser', () => {
    it('should create user successfully', () => {
      // æµ‹è¯•å®ç°
    });

    it('should throw error for duplicate email', () => {
      // æµ‹è¯•å®ç°
    });

    it('should validate required fields', () => {
      // æµ‹è¯•å®ç°
    });
  });
});
```

### Mock å’Œæµ‹è¯•æ•°æ®ç®¡ç†

```javascript
// tests/utils/mock-data.js
export const mockUsers = {
  activeUser: {
    id: 'user_123',
    username: 'johndoe',
    email: 'john@example.com',
    role: 'user',
    status: 'active',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01')
  },

  adminUser: {
    id: 'user_456',
    username: 'admin',
    email: 'admin@example.com',
    role: 'admin',
    status: 'active',
    createdAt: new Date('2024-01-01'),
    updatedAt: new Date('2024-01-01')
  }
};

export const mockWorkflows = {
  simpleWorkflow: {
    id: 'workflow_123',
    name: 'Simple Workflow',
    tasks: [
      {
        id: 'task_1',
        name: 'Send Email',
        type: 'http',
        status: 'pending'
      }
    ],
    status: 'created',
    createdAt: new Date('2024-01-01')
  }
};

// tests/utils/test-helpers.js
export function createMockDatabase() {
  return {
    users: {
      findById: vi.fn(),
      create: vi.fn(),
      update: vi.fn(),
      delete: vi.fn(),
      find: vi.fn()
    },
    workflows: {
      findById: vi.fn(),
      create: vi.fn(),
      update: vi.fn()
    }
  };
}

export function createMockHttpClient() {
  return {
    get: vi.fn(),
    post: vi.fn(),
    put: vi.fn(),
    delete: vi.fn(),
    interceptors: {
      request: { use: vi.fn() },
      response: { use: vi.fn() }
    }
  };
}

export async function setupTestDatabase() {
  const database = createMockDatabase();

  // è®¾ç½®é»˜è®¤è¡Œä¸º
  database.users.findById.mockResolvedValue(null);
  database.workflows.findById.mockResolvedValue(null);

  return database;
}
```

### æµ‹è¯•æ‰§è¡Œä¼˜åŒ–

```javascript
// vitest.config.js - ä¼˜åŒ–é…ç½®
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    // å¹¶è¡Œæ‰§è¡Œ
    pool: 'threads',
    poolOptions: {
      threads: {
        singleThread: false,
        useAtomics: true
      }
    },

    // æŒ‰æ–‡ä»¶å¤§å°æ’åºï¼Œå…ˆæ‰§è¡Œå¿«çš„æµ‹è¯•
    sequence: {
      sequencer: (tests) => {
        return tests.sort((a, b) => {
          // ç®€å•çš„å¯å‘å¼ï¼šæ›´å°çš„æ–‡ä»¶å¯èƒ½æ›´å¿«
          return a.filepath.length - b.filepath.length;
        });
      }
    },

    // å…¨å±€æµ‹è¯•è¶…æ—¶
    testTimeout: 10000,

    // Hook è¶…æ—¶
    hookTimeout: 20000,

    // é‡è¯•å¤±è´¥çš„æµ‹è¯•
    retry: 2,

    // æ£€æµ‹å†…å­˜æ³„æ¼
    detectOpenHandles: true,

    // æ£€æµ‹å†…å­˜æ³„æ¼ï¼ˆå®éªŒæ€§ï¼‰
    // detectMemoryLeaks: true,

    // éš”ç¦»æµ‹è¯•ç¯å¢ƒ
    isolate: true,

    // å…¨å±€è®¾ç½®
    globals: true,

    // ç¯å¢ƒå˜é‡
    env: {
      NODE_ENV: 'test',
      DATABASE_URL: 'postgresql://test:test@localhost:5432/testdb'
    }
  }
});
```

## ğŸ“š æ€»ç»“

frys çš„æµ‹è¯•æ¶æ„é‡‡ç”¨å…¨é¢çš„åˆ†å±‚æµ‹è¯•ç­–ç•¥ï¼Œç¡®ä¿ä»£ç è´¨é‡å’Œç³»ç»Ÿç¨³å®šæ€§ï¼š

### æµ‹è¯•å±‚æ¬¡è¦†ç›–
- **å•å…ƒæµ‹è¯•**: éªŒè¯æ ¸å¿ƒé€»è¾‘çš„æ­£ç¡®æ€§
- **é›†æˆæµ‹è¯•**: ç¡®ä¿æ¨¡å—é—´åä½œæ­£å¸¸
- **ç«¯åˆ°ç«¯æµ‹è¯•**: éªŒè¯å®Œæ•´ç”¨æˆ·æµç¨‹
- **æ€§èƒ½æµ‹è¯•**: ä¿è¯ç³»ç»Ÿæ€§èƒ½è¡¨ç°
- **å®‰å…¨æµ‹è¯•**: é˜²èŒƒå®‰å…¨æ¼æ´é£é™©

### è´¨é‡ä¿éšœæªæ–½
- è‡ªåŠ¨åŒ–æµ‹è¯•æ‰§è¡Œå’ŒæŠ¥å‘Šç”Ÿæˆ
- ä»£ç è¦†ç›–ç‡ç›‘æ§å’Œé—¨ç¦è®¾ç½®
- æŒç»­é›†æˆä¸­çš„è´¨é‡æ£€æŸ¥
- æ€§èƒ½åŸºå‡†å’Œå®‰å…¨æ‰«æ

### æœ€ä½³å®è·µ
- æµ‹è¯•é©±åŠ¨å¼€å‘ (TDD)
- è¡Œä¸ºé©±åŠ¨æµ‹è¯• (BDD)
- Mock å’Œ Stub çš„åˆç†ä½¿ç”¨
- æµ‹è¯•æ•°æ®ç®¡ç†å’Œæ¸…ç†
- å¹¶è¡Œæµ‹è¯•æ‰§è¡Œä¼˜åŒ–

é€šè¿‡å®Œå–„çš„æµ‹è¯•ä½“ç³»ï¼Œfrys ç¡®ä¿äº†ç³»ç»Ÿçš„å¯é æ€§ã€å¯ç»´æŠ¤æ€§å’Œå®‰å…¨æ€§ï¼Œä¸ºç”Ÿäº§ç¯å¢ƒçš„ä½¿ç”¨æä¾›äº†åšå®çš„è´¨é‡ä¿éšœã€‚
